package org.nem.ncc.wallet;

import net.minidev.json.*;
import org.hamcrest.core.*;
import org.junit.*;
import org.nem.core.crypto.PrivateKey;
import org.nem.core.serialization.JsonSerializer;
import org.nem.core.utils.HexEncoder;
import org.nem.ncc.test.*;

import java.math.BigInteger;
import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Collectors;

public abstract class WalletTest {

	/**
	 * Creates a new wallet with the specified name.
	 *
	 * @param name The wallet name.
	 */
	protected abstract Wallet createWallet(final WalletName name);

	/**
	 * Creates a new wallet with the specified name and primary account.
	 *
	 * @param name The wallet name.
	 * @param primaryAccount The primary account.
	 */
	protected abstract Wallet createWallet(final WalletName name, final WalletAccount primaryAccount);

	/**
	 * Creates a new wallet with the specified name, primary account, and other accounts.
	 *
	 * @param name The wallet name.
	 * @param primaryAccount The primary account.
	 * @param otherAccounts The other accounts.
	 */
	protected abstract Wallet createWallet(final WalletName name, final WalletAccount primaryAccount, final Collection<WalletAccount> otherAccounts);

	//region creation

	@Test
	public void walletCanBeCreatedAroundAutoGeneratedPrimaryAccount() {
		// Act:
		final Wallet wallet = this.createWallet(new WalletName("bar"));

		// Assert:
		Assert.assertThat(wallet.getName(), IsEqual.equalTo(new WalletName("bar")));
		Assert.assertThat(wallet.getPrimaryAccount(), IsNull.notNullValue());
		Assert.assertThat(wallet.getOtherAccounts().size(), IsEqual.equalTo(0));
	}

	@Test
	public void walletCanBeCreatedAroundSpecificPrimaryAccount() {
		// Act:
		final WalletAccount account = new WalletAccount();
		final Wallet wallet = this.createWallet(new WalletName("bar"), account);

		// Assert:
		Assert.assertThat(wallet.getName(), IsEqual.equalTo(new WalletName("bar")));
		Assert.assertThat(wallet.getPrimaryAccount(), IsSame.sameInstance(account));
		Assert.assertThat(wallet.getOtherAccounts().size(), IsEqual.equalTo(0));
	}

	@Test
	public void walletCanBeCreatedAroundSpecificPrimaryAccountAndOtherAccounts() {
		// Act:
		final WalletAccount account = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), account, otherAccounts);

		// Assert:
		Assert.assertThat(wallet.getName(), IsEqual.equalTo(new WalletName("bar")));
		Assert.assertThat(wallet.getPrimaryAccount(), IsSame.sameInstance(account));
		Assert.assertThat(wallet.getOtherAccounts(), IsEquivalent.equivalentTo(otherAccounts));
	}

	@Test
	public void walletCannotBeCreatedAroundInvalidAccounts() {
		// Arrange:
		final WalletAccount account = new WalletAccount();

		// Act:
		assertThrowsWalletException(
				v -> this.createWallet(new WalletName("bar"), account, Collections.singletonList(account)),
				WalletException.Code.WALLET_ALREADY_CONTAINS_ACCOUNT);
	}

	@Test
	public void walletConstructorMakesCopyOfWalletAccounts() {
		// Act:
		final WalletAccount account = new WalletAccount();
		final List<WalletAccount> otherAccounts = new ArrayList<>(
				Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount()));
		final Wallet wallet = this.createWallet(new WalletName("bar"), account, otherAccounts);
		otherAccounts.add(new WalletAccount());

		// Assert:
		Assert.assertThat(wallet.getOtherAccounts().size(), IsEqual.equalTo(3));
		Assert.assertThat(otherAccounts.size(), IsEqual.equalTo(4));
	}

	@Test
	public void walletCannotBeCreatedAroundNullParameters() {
		// Arrange:
		final List<Consumer<Void>> consumers = Arrays.asList(
				v -> this.createWallet(null, new WalletAccount()),
				v -> this.createWallet(new WalletName("bar"), null),
				v -> this.createWallet(null, new WalletAccount(), Collections.emptyList()),
				v -> this.createWallet(new WalletName("bar"), null, Collections.emptyList()),
				v -> this.createWallet(new WalletName("bar"), new WalletAccount(), null));

		// Act:
		for (final Consumer<Void> consumer : consumers) {
			ExceptionAssert.assertThrows(consumer, IllegalArgumentException.class);
		}
	}

	//endregion

	//region addOtherAccount / getOtherAccounts

	@Test
	public void nullOtherAccountsCannotBeAddedToWallet() {
		// Arrange:
		final Wallet wallet = this.createWallet(new WalletName("bar"));

		// Assert:
		ExceptionAssert.assertThrows(v -> wallet.addOtherAccount(null), IllegalArgumentException.class);
	}

	@Test
	public void existingAccountsCannotBeAddedToWallet() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final WalletAccount otherAccount = new WalletAccount();
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		wallet.addOtherAccount(otherAccount);

		// Assert:
		assertThrowsWalletException(v -> wallet.addOtherAccount(primaryAccount), WalletException.Code.WALLET_ALREADY_CONTAINS_ACCOUNT);
		assertThrowsWalletException(v -> wallet.addOtherAccount(otherAccount), WalletException.Code.WALLET_ALREADY_CONTAINS_ACCOUNT);
	}

	@Test
	public void otherAccountsCanBeAddedToWallet() {
		// Act:
		final List<WalletAccount> accounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"));
		accounts.forEach(wallet::addOtherAccount);

		// Assert:
		Assert.assertThat(wallet.getOtherAccounts().size(), IsEqual.equalTo(3));
		Assert.assertThat(wallet.getOtherAccounts(), IsEquivalent.equivalentTo(accounts));
	}

	@Test
	public void otherAccountsCannotBeModifiedDirectly() {
		// Act:
		final List<WalletAccount> accounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"));
		accounts.forEach(wa -> wallet.getOtherAccounts().add(wa));

		// Assert:
		Assert.assertThat(wallet.getOtherAccounts().size(), IsEqual.equalTo(0));
	}

	//endregion

	//region removeAccount

	@Test
	public void canRemoveOtherAccount() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		otherAccounts.forEach(wallet::addOtherAccount);

		// Act:
		wallet.removeAccount(otherAccounts.get(1).getAddress());

		// Assert:
		Assert.assertThat(
				wallet.getOtherAccounts(),
				IsEquivalent.equivalentTo(Arrays.asList(otherAccounts.get(0), otherAccounts.get(2))));
	}

	@Test
	public void cannotRemovePrimaryAccount() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final WalletAccount otherAccount = new WalletAccount();
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		wallet.addOtherAccount(otherAccount);

		// Act:
		assertThrowsWalletException(
				v -> wallet.removeAccount(primaryAccount.getAddress()),
				WalletException.Code.WALLET_PRIMARY_ACCOUNT_CANNOT_BE_REMOVED);
	}

	@Test
	public void cannotRemoveAccountNotInWallet() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final WalletAccount otherAccount = new WalletAccount();
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		wallet.addOtherAccount(otherAccount);

		// Act:
		assertThrowsWalletException(
				v -> wallet.removeAccount(Utils.generateRandomAddress()),
				WalletException.Code.WALLET_ACCOUNT_NOT_IN_WALLET);
	}

	//endregion

	//region setPrimaryAccount

	@Test
	public void primaryAccountCannotBeSetToNullAccount() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		otherAccounts.forEach(wallet::addOtherAccount);

		// Act:
		ExceptionAssert.assertThrows(v -> wallet.setPrimaryAccount(null), IllegalArgumentException.class);
	}

	@Test
	public void primaryAccountCanBeSetToCurrentPrimaryAccount() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		otherAccounts.forEach(wallet::addOtherAccount);

		// Act:
		wallet.setPrimaryAccount(primaryAccount.getAddress());

		// Assert:
		Assert.assertThat(wallet.getPrimaryAccount(), IsEqual.equalTo(primaryAccount));
		Assert.assertThat(wallet.getOtherAccounts(), IsEquivalent.equivalentTo(otherAccounts));
	}

	@Test
	public void primaryAccountCanBeSetToOtherAccount() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		otherAccounts.forEach(wallet::addOtherAccount);

		// Act:
		wallet.setPrimaryAccount(otherAccounts.get(1).getAddress());

		// Assert:
		final List<WalletAccount> expectedOtherAccounts = Arrays.asList(
				primaryAccount,
				otherAccounts.get(0),
				otherAccounts.get(2));
		Assert.assertThat(wallet.getPrimaryAccount(), IsEqual.equalTo(otherAccounts.get(1)));
		Assert.assertThat(wallet.getOtherAccounts(), IsEquivalent.equivalentTo(expectedOtherAccounts));
	}

	@Test
	public void primaryAccountCannotBeSetToNewAccount() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		otherAccounts.forEach(wallet::addOtherAccount);

		// Act:
		assertThrowsWalletException(
				v -> wallet.setPrimaryAccount(Utils.generateRandomAddress()),
				WalletException.Code.WALLET_ACCOUNT_NOT_IN_WALLET);

		// Assert:
		Assert.assertThat(wallet.getPrimaryAccount(), IsEqual.equalTo(primaryAccount));
		Assert.assertThat(wallet.getOtherAccounts(), IsEquivalent.equivalentTo(otherAccounts));
	}

	//endregion

	//region getAccountPrivateKey

	@Test
	public void privateKeyCanBeRetrievedForPrimaryAccount() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		otherAccounts.forEach(wallet::addOtherAccount);

		// Act:
		final PrivateKey privateKey = wallet.getAccountPrivateKey(primaryAccount.getAddress());

		// Assert:
		Assert.assertThat(privateKey, IsEqual.equalTo(primaryAccount.getPrivateKey()));
	}

	@Test
	public void privateKeyCanBeRetrievedForOtherAccount() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		otherAccounts.forEach(wallet::addOtherAccount);

		// Act:
		final PrivateKey privateKey = wallet.getAccountPrivateKey(otherAccounts.get(1).getAddress());

		// Assert:
		Assert.assertThat(privateKey, IsEqual.equalTo(otherAccounts.get(1).getPrivateKey()));
	}

	@Test
	public void privateKeyCannotBeRetrievedForAccountNotInWallet() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		otherAccounts.forEach(wallet::addOtherAccount);

		// Act:
		assertThrowsWalletException(
				v -> wallet.getAccountPrivateKey(Utils.generateRandomAddress()),
				WalletException.Code.WALLET_ACCOUNT_NOT_IN_WALLET);
	}

	//endregion

	//region tryGetWalletAccount

	@Test
	public void walletAccountCanBeRetrievedForPrimaryAccount() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		otherAccounts.forEach(wallet::addOtherAccount);

		// Act:
		final WalletAccount account = wallet.tryGetWalletAccount(primaryAccount.getAddress());

		// Assert:
		Assert.assertThat(account, IsEqual.equalTo(primaryAccount));
	}

	@Test
	public void walletAccountCanBeRetrievedForOtherAccount() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		otherAccounts.forEach(wallet::addOtherAccount);

		// Act:
		final WalletAccount account = wallet.tryGetWalletAccount(otherAccounts.get(1).getAddress());

		// Assert:
		Assert.assertThat(account, IsEqual.equalTo(otherAccounts.get(1)));
	}

	@Test
	public void walletAccountCannotBeRetrievedForAccountNotInWallet() {
		// Arrange:
		final WalletAccount primaryAccount = new WalletAccount();
		final List<WalletAccount> otherAccounts = Arrays.asList(new WalletAccount(), new WalletAccount(), new WalletAccount());
		final Wallet wallet = this.createWallet(new WalletName("bar"), primaryAccount);
		otherAccounts.forEach(wallet::addOtherAccount);

		// Act:
		final WalletAccount account = wallet.tryGetWalletAccount(Utils.generateRandomAddress());

		// Assert:
		Assert.assertThat(account, IsNull.nullValue());
	}

	//endregion

	//region serialization

	@Test
	public void walletCanBeSerialized() {
		// Arrange:
		final WalletAccount account = new WalletAccount();
		final Wallet wallet = this.createWallet(new WalletName("bar"), account);
		wallet.addOtherAccount(new WalletAccount());
		wallet.addOtherAccount(new WalletAccount());
		wallet.addOtherAccount(new WalletAccount());

		// Act:
		final JSONObject jsonObject = JsonSerializer.serializeToJson(wallet);

		// Assert:
		Assert.assertThat(jsonObject.size(), IsEqual.equalTo(3));
		Assert.assertThat(jsonObject.get("wallet"), IsEqual.equalTo("bar"));
		Assert.assertThat(getPrivateKey(jsonObject.get("primaryAccount")), IsEqual.equalTo(account.getPrivateKey()));
		Assert.assertThat(
				getPrivateKeys(jsonObject.get("otherAccounts")),
				IsEquivalent.equivalentTo(
						wallet.getOtherAccounts().stream()
								.map(WalletAccount::getPrivateKey)
								.collect(Collectors.toList())));
	}

	private static PrivateKey getPrivateKey(final Object object) {
		return new PrivateKey(new BigInteger(1, HexEncoder.getBytes((String)((JSONObject)object).get("privateKey"))));
	}

	private static List<PrivateKey> getPrivateKeys(final Object object) {
		final JSONArray jsonAccounts = (JSONArray)object;
		return jsonAccounts.stream().map(WalletTest::getPrivateKey).collect(Collectors.toList());
	}

	//endregion

	/**
	 * Asserts the specified action throws a WalletException with the expected code.
	 *
	 * @param consumer The action.
	 * @param code The expected code.
	 */
	protected static void assertThrowsWalletException(
			final Consumer<Void> consumer,
			final WalletException.Code code) {
		ExceptionAssert.assertThrows(
				consumer,
				WalletException.class,
				ex -> Assert.assertThat(ex.getCode(), IsEqual.equalTo(code)));
	}
}